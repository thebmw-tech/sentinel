using System;
using System.IO.Abstractions;
using System.Linq;
using System.Text;
using Sentinel.Core.Entities;
using Sentinel.Core.Enums;
using Sentinel.Core.Generators.Interfaces;
using Sentinel.Core.Repository.Interfaces;

namespace Sentinel.Core.Generators.IPTables
{
    public class IPTablesPersistentConfigurationGenerator : IConfigurationGenerator<Entities.FirewallRule>
    {
        private readonly IInterfaceRepository interfaceRepository;
        private readonly IFirewallTableRepository firewallTableRepository;
        private readonly IFirewallRuleRepository firewallRuleRepository;
        private readonly ISourceNatRuleRepository sourceNatRuleRepository;
        private readonly IDestinationNatRuleRepository destinationNatRuleRepository;

        private readonly IFileSystem fileSystem;

        public IPTablesPersistentConfigurationGenerator(IInterfaceRepository interfaceRepository,
            IFirewallTableRepository firewallTableRepository, IFirewallRuleRepository firewallRuleRepository,
            ISourceNatRuleRepository sourceNatRuleRepository,
            IDestinationNatRuleRepository destinationNatRuleRepository, IFileSystem fileSystem)
        {
            this.interfaceRepository = interfaceRepository;
            this.firewallTableRepository = firewallTableRepository;
            this.firewallRuleRepository = firewallRuleRepository;
            this.sourceNatRuleRepository = sourceNatRuleRepository;
            this.destinationNatRuleRepository = destinationNatRuleRepository;
            this.fileSystem = fileSystem;
        }

        public bool Apply()
        {
            throw new System.NotImplementedException();
        }

        public void Generate()
        {
            GenerateIPv4();
            GenerateIPv6();
        }

        private void GenerateIPv4()
        {
            StringBuilder builder = new StringBuilder();
            GenerateRules(builder, IPVersion.v4);
            fileSystem.File.WriteAllText("/etc/iptables/rules.v4", builder.ToString());
        }

        private void GenerateIPv6()
        {
            StringBuilder builder = new StringBuilder();
            GenerateRules(builder, IPVersion.v6);
            fileSystem.File.WriteAllText("/etc/iptables/rules.v6", builder.ToString());
        }

        private void GenerateRules(StringBuilder builder, IPVersion version)
        {
            GenerateFilterRules(builder, version);
            GenerateNatRules(builder, version);
        }

        private void GenerateFilterRules(StringBuilder builder, IPVersion version)
        {
            builder.Append($"# Generated by Sentinel on {DateTime.Now}\n");
            builder.Append("*filter\n");
            builder.Append(":INPUT ACCEPT [0:0]\n");
            builder.Append(":FORWARD ACCEPT [0:0]\n");
            builder.Append(":OUTPUT ACCEPT [0:0]\n");

            GenerateFirewallTableHeaders(builder);
            GenerateFirewallTableInterfaceMappings(builder);
            GenerateFirewallTables(builder, version);

            builder.Append("COMMIT\n");
            builder.Append($"# Completed on {DateTime.Now}\n");
        }

        private void GenerateFirewallTableHeaders(StringBuilder builder)
        {
            var tables = firewallTableRepository.GetCurrent();
            foreach (var table in tables)
            {
                builder.Append($":{GuidToTableName(table.Id)} - [0:0]\n");
            }
        }

        private void GenerateFirewallTableInterfaceMappings(StringBuilder builder)
        {
            var interfaces = interfaceRepository.GetCurrent().Where(i =>
                i.InboundFirewallTableId.HasValue || i.OutboundFirewallTableId.HasValue ||
                i.LocalFirewallTableId.HasValue);
            foreach (var iface in interfaces)
            {
                GenerateFirewallTableInterfaceMapping(builder, iface);
            }
        }

        private void GenerateFirewallTableInterfaceMapping(StringBuilder builder, Interface iface)
        {
            if (iface.LocalFirewallTableId.HasValue)
            {
                builder.Append($"-A INPUT -i {iface.Name} -j {GuidToTableName(iface.LocalFirewallTableId.Value)}\n");
            }

            if (iface.InboundFirewallTableId.HasValue)
            {
                builder.Append($"-A FORWARD -i {iface.Name} -j {GuidToTableName(iface.InboundFirewallTableId.Value)}\n");
            }

            if (iface.OutboundFirewallTableId.HasValue)
            {
                builder.Append($"-A FORWARD -o {iface.Name} -j {GuidToTableName(iface.OutboundFirewallTableId.Value)}\n");
            }
        }

        private void GenerateFirewallTables(StringBuilder builder, IPVersion version)
        {
            var tables = firewallTableRepository.GetCurrent();
            foreach (var table in tables)
            {
                GenerateFirewallTableRules(builder, table, version);
                GenerateFirewallTableDefaultRule(builder, table);
            }
        }

        private void GenerateFirewallTableRules(StringBuilder builder, FirewallTable table, IPVersion version)
        {
            var rules = firewallRuleRepository.GetCurrent().Where(r => r.FirewallTableId == table.Id && r.IPVersion == version)
                .OrderBy(r => r.Order);
            foreach (var rule in rules)
            {
                GenerateFirewallTableRule(builder, rule);
            }
        }

        private void GenerateFirewallTableRule(StringBuilder builder, FirewallRule rule)
        {
            builder.Append($"-A {GuidToTableName(rule.FirewallTableId)} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);

            // TODO handle logging
            builder.Append($"-j {FirewallActionToIptables(rule.Action)}\n");
        }

        private void GenerateFirewallTableDefaultRule(StringBuilder builder, FirewallTable table)
        {
            // TODO handle logging
            
            builder.Append($"-A {GuidToTableName(table.Id)} -j {FirewallActionToIptables(table.DefaultAction)}\n");
        }

        private void GenerateNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append($"# Generated by Sentinel on {DateTime.Now}\n");
            builder.Append("*nat\n");
            builder.Append(":PREROUTING ACCEPT [0:0]\n");
            builder.Append(":INPUT ACCEPT [0:0]\n");
            builder.Append(":POSTROUTING ACCEPT [0:0]\n");
            builder.Append(":OUTPUT ACCEPT [0:0]\n");

            GenerateSourceNatRules(builder, version);
            GenerateDestinationNatRules(builder, version);

            builder.Append("COMMIT\n");
            builder.Append($"# Completed on {DateTime.Now}\n");
        }

        private void GenerateSourceNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append("# Source NAT rules\n");
            var sourceRules = sourceNatRuleRepository.GetCurrent().Where(r => r.IPVersion == version && r.Enabled)
                .OrderBy(r => r.Order);

            foreach (var rule in sourceRules)
            {
                GenerateSourceNatRule(builder, rule);
            }
        }

        private void GenerateSourceNatRule(StringBuilder builder, SourceNatRule rule)
        {
            builder.Append($"-t nat -A POSTROUTING -o {rule.OutboundInterfaceName} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);

            if (!String.IsNullOrEmpty(rule.TranslationAddress))
            {
                builder.Append($"-j SNAT --to {rule.TranslationAddress}");
                if (rule.TranslationPortRangeStart.HasValue && rule.TranslationPortRangeEnd.HasValue)
                {
                    if (rule.TranslationPortRangeStart != rule.SourcePortRangeStart &&
                        rule.TranslationPortRangeEnd != rule.SourcePortRangeStart)
                    {
                        builder.Append(
                            $":{BuildPortRange(rule.TranslationPortRangeStart.Value, rule.TranslationPortRangeEnd.Value, '-')}");
                    }
                }
                else
                {
                    builder.Append($"/{rule.TranslationSubnetMask}");
                }
            }
            else
            {
                builder.Append("-j MASQUERADE");
            }

            builder.Append("\n");
        }

        private void GenerateDestinationNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append("# Destination NAT rules\n");
            var dstRules = destinationNatRuleRepository.GetCurrent().Where(r => r.IPVersion == version && r.Enabled)
                .OrderBy(r => r.Order);

            foreach (var rule in dstRules)
            {
                GenerateDestinationNatRule(builder, rule);
            }
        }

        private void GenerateDestinationNatRule(StringBuilder builder, DestinationNatRule rule)
        {
            builder.Append($"-t nat -A PREROUTING -i {rule.InboundInterfaceName} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);

            builder.Append($"-j DNAT --to-destination {rule.TranslationAddress}");
            if (rule.TranslationPortRangeStart.HasValue && rule.TranslationPortRangeEnd.HasValue)
            {
                if (rule.TranslationPortRangeStart != rule.DestinationPortRangeStart &&
                    rule.TranslationPortRangeEnd != rule.DestinationPortRangeEnd)
                {
                    builder.Append(
                        $":{BuildPortRange(rule.TranslationPortRangeStart.Value, rule.TranslationPortRangeEnd.Value, '-')}");
                }
            }

            builder.Append("\n");
        }

        private void TryAppendSourceAddress<T>(StringBuilder builder, BaseRule<T> rule) where T : BaseRule<T>
        {
            if (!String.IsNullOrEmpty(rule.SourceAddress))
            {
                if (rule.InvertSourceMatch)
                {
                    builder.Append("! ");
                }
                builder.Append($"-s {rule.SourceAddress}/{rule.SourceSubnetMask} ");
                if (rule.SourcePortRangeStart.HasValue && rule.SourcePortRangeEnd.HasValue)
                {
                    builder.Append(
                        $"--sport {BuildPortRange(rule.SourcePortRangeStart.Value, rule.SourcePortRangeEnd.Value)} ");
                }
            }
        }

        private void TryAppendDestinationAddress<T>(StringBuilder builder, BaseRule<T> rule) where T : BaseRule<T>
        {
            if (!String.IsNullOrEmpty(rule.DestinationAddress))
            {
                if (rule.InvertDestinationMatch)
                {
                    builder.Append("! ");
                }
                builder.Append($"-d {rule.DestinationAddress}/{rule.DestinationSubnetMask} ");
                if (rule.DestinationPortRangeStart.HasValue && rule.DestinationPortRangeEnd.HasValue)
                {
                    builder.Append(
                        $"--dport {BuildPortRange(rule.DestinationPortRangeStart.Value, rule.DestinationPortRangeEnd.Value)} ");
                }
            }
        }

        private string FirewallActionToIptables(FirewallAction action)
        {
            switch (action)
            {
                case FirewallAction.Pass:
                    return "ACCEPT";
                case FirewallAction.Reject:
                    return "REJECT";
                case FirewallAction.Block:
                    return "DROP";
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string ProtocolToString(IPProtocol protocol)
        {
            switch (protocol)
            {
                case IPProtocol.Any:
                    return "";
                case IPProtocol.TCP:
                    return "-p tcp ";
                case IPProtocol.UDP:
                    return "-p udp ";
                case IPProtocol.ICMP:
                    return "-p icmp ";
                default:
                    throw new NotSupportedException();
            }
        }

        private string BuildPortRange(ushort start, ushort end, char seperator = ':')
        {
            if (start == end)
            {
                return start.ToString();
            }

            if (start > end)
            {
                throw new ArgumentOutOfRangeException();
            }

            return $"{start}{seperator}{end}";
        }

        private string GuidToTableName(Guid guid)
        {
            return guid.ToString("D").Substring(0, 23);
        }
    }
}