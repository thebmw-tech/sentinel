using System;
using System.Collections.Generic;
using System.Data;
using System.IO.Abstractions;
using System.Linq;
using System.Text;
using Microsoft.Extensions.Logging;
using Sentinel.Core.Entities;
using Sentinel.Core.Enums;
using Sentinel.Core.Generators.Interfaces;
using Sentinel.Core.Helpers;
using Sentinel.Core.Repository.Interfaces;

namespace Sentinel.Core.Generators.IPTables
{
    public class IPTablesPersistentConfigurationGenerator : IConfigurationGenerator<IPTablesPersistentConfigurationGenerator>
    {
        private const string IPv4_CONFIG = "/etc/iptables/rules.v4";
        private const string IPv6_CONFIG = "/etc/iptables/rules.v6";

        private readonly IInterfaceRepository interfaceRepository;
        private readonly IFirewallTableRepository firewallTableRepository;
        private readonly IFirewallRuleRepository firewallRuleRepository;
        private readonly ISourceNatRuleRepository sourceNatRuleRepository;
        private readonly IDestinationNatRuleRepository destinationNatRuleRepository;

        private readonly ICommandExecutionHelper commandExecutionHelper;

        private readonly IFileSystem fileSystem;

        private readonly ILogger<IPTablesPersistentConfigurationGenerator> logger;

        public IPTablesPersistentConfigurationGenerator(IInterfaceRepository interfaceRepository,
            IFirewallTableRepository firewallTableRepository, IFirewallRuleRepository firewallRuleRepository,
            ISourceNatRuleRepository sourceNatRuleRepository,
            IDestinationNatRuleRepository destinationNatRuleRepository,
            ICommandExecutionHelper commandExecutionHelper, IFileSystem fileSystem,
            ILogger<IPTablesPersistentConfigurationGenerator> logger)
        {
            this.interfaceRepository = interfaceRepository;
            this.firewallTableRepository = firewallTableRepository;
            this.firewallRuleRepository = firewallRuleRepository;
            this.sourceNatRuleRepository = sourceNatRuleRepository;
            this.destinationNatRuleRepository = destinationNatRuleRepository;
            
            this.commandExecutionHelper = commandExecutionHelper;
            
            this.fileSystem = fileSystem;
            
            this.logger = logger;
        }

        public void Apply()
        {
            ApplyFileToCommand("iptables-restore", IPv4_CONFIG);
            ApplyFileToCommand("ip6tables-restore", IPv6_CONFIG);
        }

        private void ApplyFileToCommand(string command, string fileName)
        {
            var process =
                commandExecutionHelper.BuildProcess(command, rdrInput: true, rdrOutput: true, rdrError: true);

            var fileContent = fileSystem.File.ReadAllText(fileName);

            process.StandardInput.Write(fileContent);

            var outStringBuilder = new StringBuilder();
            var errorStringBuilder = new StringBuilder();

            process.ErrorDataReceived += (sender, eventArgs) => errorStringBuilder.Append(eventArgs.Data);
            process.OutputDataReceived += (sender, eventArgs) => outStringBuilder.Append(eventArgs.Data);

            process.Start();
            process.BeginErrorReadLine();
            process.BeginOutputReadLine();
            process.WaitForExit();

            if (process.ExitCode > 0)
            {
                logger.LogError($"{command} failed with exit code {process.ExitCode}");
                logger.LogError(outStringBuilder.ToString());
                logger.LogError(errorStringBuilder.ToString());
                throw new Exception($"{command} failed with exit code {process.ExitCode}");
            }
        }

        public void Generate()
        {
            GenerateIPv4();
            GenerateIPv6();
        }

        private void GenerateIPv4()
        {
            StringBuilder builder = new StringBuilder();
            GenerateRules(builder, IPVersion.v4);
            fileSystem.File.WriteAllText(IPv4_CONFIG, builder.ToString());
        }

        private void GenerateIPv6()
        {
            StringBuilder builder = new StringBuilder();
            GenerateRules(builder, IPVersion.v6);
            fileSystem.File.WriteAllText(IPv6_CONFIG, builder.ToString());
        }

        private void GenerateRules(StringBuilder builder, IPVersion version)
        {
            GenerateFilterRules(builder, version);
            GenerateNatRules(builder, version);
        }

        private void GenerateFilterRules(StringBuilder builder, IPVersion version)
        {
            builder.Append($"# Generated by Sentinel on {DateTime.Now}\n");
            builder.Append("*filter\n");
            builder.Append(":INPUT ACCEPT [0:0]\n");
            builder.Append(":FORWARD ACCEPT [0:0]\n");
            builder.Append(":OUTPUT ACCEPT [0:0]\n");

            GenerateFirewallTableHeaders(builder);
            GenerateFirewallTableInterfaceMappings(builder);
            GenerateFirewallTables(builder, version);

            builder.Append("COMMIT\n");
            builder.Append($"# Completed on {DateTime.Now}\n");
        }

        private void GenerateFirewallTableHeaders(StringBuilder builder)
        {
            var tables = firewallTableRepository.GetCurrent();
            foreach (var table in tables)
            {
                builder.Append($":{table.Name} - [0:0]\n");
            }
        }

        private void GenerateFirewallTableInterfaceMappings(StringBuilder builder)
        {
            builder.Append("# Filter Table Interface Mappings\n");
            var interfaces = interfaceRepository.GetCurrent().Where(i =>
                i.InboundFirewallTableId.HasValue || i.OutboundFirewallTableId.HasValue ||
                i.LocalFirewallTableId.HasValue);
            foreach (var iface in interfaces)
            {
                GenerateFirewallTableInterfaceMapping(builder, iface);
            }
        }

        private void GenerateFirewallTableInterfaceMapping(StringBuilder builder, Interface iface)
        {
            builder.Append($"# Mappings for '{iface.Name}'\n");
            if (iface.LocalFirewallTableId.HasValue)
            {
                builder.Append($"-A INPUT -i {iface.Name} -j {GuidToTableName(iface.LocalFirewallTableId.Value)}\n");
            }

            if (iface.InboundFirewallTableId.HasValue)
            {
                builder.Append($"-A FORWARD -i {iface.Name} -j {GuidToTableName(iface.InboundFirewallTableId.Value)}\n");
            }

            if (iface.OutboundFirewallTableId.HasValue)
            {
                builder.Append($"-A FORWARD -o {iface.Name} -j {GuidToTableName(iface.OutboundFirewallTableId.Value)}\n");
            }
        }

        private void GenerateFirewallTables(StringBuilder builder, IPVersion version)
        {
            var tables = firewallTableRepository.GetCurrent();
            foreach (var table in tables)
            {
                GenerateFirewallTableRules(builder, table, version);
            }
        }

        private void GenerateFirewallTableRules(StringBuilder builder, FirewallTable table, IPVersion version)
        {
            builder.Append($"# Rules for table {table.Name} {table.Id:B}\n");
            var rules = firewallRuleRepository.GetCurrent().Where(r => r.FirewallTableId == table.Id && (r.IPVersion == version || r.IPVersion == IPVersion.Both))
                .OrderBy(r => r.Order);
            foreach (var rule in rules)
            {
                GenerateFirewallTableRule(builder, table, rule);
            }

            GenerateFirewallTableDefaultRule(builder, table);
        }

        private void GenerateFirewallTableRule(StringBuilder builder, FirewallTable table, FirewallRule rule)
        {
            builder.Append($"-A {table.Name} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);
            AppendState(builder, rule);

            // TODO handle logging
            builder.Append($"-j {FirewallActionToIptables(rule.Action)}\n");
        }

        private void GenerateFirewallTableDefaultRule(StringBuilder builder, FirewallTable table)
        {
            // TODO handle logging
            
            builder.Append($"-A {table.Name} -j {FirewallActionToIptables(table.DefaultAction)}\n");
        }

        private void GenerateNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append($"# Generated by Sentinel on {DateTime.Now}\n");
            builder.Append("*nat\n");
            builder.Append(":PREROUTING ACCEPT [0:0]\n");
            builder.Append(":INPUT ACCEPT [0:0]\n");
            builder.Append(":POSTROUTING ACCEPT [0:0]\n");
            builder.Append(":OUTPUT ACCEPT [0:0]\n");

            GenerateSourceNatRules(builder, version);
            GenerateDestinationNatRules(builder, version);

            builder.Append("COMMIT\n");
            builder.Append($"# Completed on {DateTime.Now}\n");
        }

        private void GenerateSourceNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append("# Source NAT rules\n");
            var sourceRules = sourceNatRuleRepository.GetCurrent().Where(r => r.IPVersion == version && r.Enabled)
                .OrderBy(r => r.Order);

            foreach (var rule in sourceRules)
            {
                GenerateSourceNatRule(builder, rule);
            }
        }

        private void GenerateSourceNatRule(StringBuilder builder, SourceNatRule rule)
        {
            builder.Append($"-A POSTROUTING -o {rule.OutboundInterfaceName} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);

            if (!String.IsNullOrEmpty(rule.TranslationAddress))
            {
                builder.Append($"-j SNAT --to {rule.TranslationAddress}");
                if (rule.TranslationPortRangeStart.HasValue && rule.TranslationPortRangeEnd.HasValue)
                {
                    if (rule.TranslationPortRangeStart != rule.SourcePortRangeStart &&
                        rule.TranslationPortRangeEnd != rule.SourcePortRangeStart)
                    {
                        builder.Append(
                            $":{BuildPortRange(rule.TranslationPortRangeStart.Value, rule.TranslationPortRangeEnd.Value, '-')}");
                    }
                }
                else
                {
                    builder.Append($"/{rule.TranslationSubnetMask}");
                }
            }
            else
            {
                builder.Append("-j MASQUERADE");
            }

            builder.Append("\n");
        }

        private void GenerateDestinationNatRules(StringBuilder builder, IPVersion version)
        {
            builder.Append("# Destination NAT rules\n");
            var dstRules = destinationNatRuleRepository.GetCurrent().Where(r => r.IPVersion == version && r.Enabled)
                .OrderBy(r => r.Order);

            foreach (var rule in dstRules)
            {
                GenerateDestinationNatRule(builder, rule);
            }
        }

        private void GenerateDestinationNatRule(StringBuilder builder, DestinationNatRule rule)
        {
            builder.Append($"-A PREROUTING -i {rule.InboundInterfaceName} {ProtocolToString(rule.Protocol)}");

            TryAppendSourceAddress(builder, rule);
            TryAppendDestinationAddress(builder, rule);

            builder.Append($"-j DNAT --to-destination {rule.TranslationAddress}");
            if (rule.TranslationPortRangeStart.HasValue && rule.TranslationPortRangeEnd.HasValue)
            {
                if (rule.TranslationPortRangeStart != rule.DestinationPortRangeStart &&
                    rule.TranslationPortRangeEnd != rule.DestinationPortRangeEnd)
                {
                    builder.Append(
                        $":{BuildPortRange(rule.TranslationPortRangeStart.Value, rule.TranslationPortRangeEnd.Value, '-')}");
                }
            }

            builder.Append("\n");
        }

        private void TryAppendSourceAddress<T>(StringBuilder builder, BaseRule<T> rule) where T : BaseRule<T>
        {
            if (!String.IsNullOrEmpty(rule.SourceAddress))
            {
                if (rule.InvertSourceMatch)
                {
                    builder.Append("! ");
                }
                builder.Append($"-s {rule.SourceAddress}/{rule.SourceSubnetMask} ");
                if (rule.SourcePortRangeStart.HasValue && rule.SourcePortRangeEnd.HasValue)
                {
                    builder.Append(
                        $"--sport {BuildPortRange(rule.SourcePortRangeStart.Value, rule.SourcePortRangeEnd.Value)} ");
                }
            }
        }

        private void TryAppendDestinationAddress<T>(StringBuilder builder, BaseRule<T> rule) where T : BaseRule<T>
        {
            if (!String.IsNullOrEmpty(rule.DestinationAddress))
            {
                if (rule.InvertDestinationMatch)
                {
                    builder.Append("! ");
                }
                builder.Append($"-d {rule.DestinationAddress}/{rule.DestinationSubnetMask} ");
                if (rule.DestinationPortRangeStart.HasValue && rule.DestinationPortRangeEnd.HasValue)
                {
                    builder.Append(
                        $"--dport {BuildPortRange(rule.DestinationPortRangeStart.Value, rule.DestinationPortRangeEnd.Value)} ");
                }
            }
        }

        private void AppendState(StringBuilder builder, FirewallRule rule)
        {
            if (rule.State != FirewallState.None)
            {
                List<string> flags = new List<string>();
                if (rule.State.HasFlag(FirewallState.New))
                {
                    flags.Add("NEW");
                }

                if (rule.State.HasFlag(FirewallState.Invalid))
                {
                    flags.Add("INVALID");
                }

                if (rule.State.HasFlag(FirewallState.Established))
                {
                    flags.Add("ESTABLISHED");
                }

                if (rule.State.HasFlag(FirewallState.Related))
                {
                    flags.Add("RELATED");
                }

                builder.Append($"-m state --state {string.Join(',', flags.ToArray())} ");
            }
        }

        private string FirewallActionToIptables(FirewallAction action)
        {
            switch (action)
            {
                case FirewallAction.Pass:
                    return "ACCEPT";
                case FirewallAction.Reject:
                    return "REJECT";
                case FirewallAction.Block:
                    return "DROP";
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string ProtocolToString(IPProtocol protocol)
        {
            switch (protocol)
            {
                case IPProtocol.Any:
                    return "";
                case IPProtocol.TCP:
                    return "-p tcp ";
                case IPProtocol.UDP:
                    return "-p udp ";
                case IPProtocol.ICMP:
                    return "-p icmp ";
                default:
                    throw new NotSupportedException();
            }
        }

        private string BuildPortRange(ushort start, ushort end, char seperator = ':')
        {
            if (start == end)
            {
                return start.ToString();
            }

            if (start > end)
            {
                throw new ArgumentOutOfRangeException();
            }

            return $"{start}{seperator}{end}";
        }

        private string GuidToTableName(Guid guid)
        {
            var table = firewallTableRepository.GetCurrent().First(t => t.Id == guid);
            return table.Name;
        }
    }
}